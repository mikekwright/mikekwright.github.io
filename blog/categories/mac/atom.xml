<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Mac | My Fortress of Solitude]]></title>
  <link href="http://www.mikewright.me/blog/categories/mac/atom.xml" rel="self"/>
  <link href="http://www.mikewright.me/"/>
  <updated>2015-04-28T11:43:05-06:00</updated>
  <id>http://www.mikewright.me/</id>
  <author>
    <name><![CDATA[Michael Wright]]></name>
    <email><![CDATA[mkwright@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Docker]]></title>
    <link href="http://www.mikewright.me/blog/2015/02/06/docker/"/>
    <updated>2015-02-06T15:23:00-07:00</updated>
    <id>http://www.mikewright.me/blog/2015/02/06/docker</id>
    <content type="html"><![CDATA[<p>I love Docker and I really enjoy developing on a stable nix-like environment.  But with the
current limitation of the docker daemon requiring the linux kernel to work, I am left trying
to create the best experience that I can while developing on a mac.</p>

<!-- more -->


<h2>Why not just use boot2docker</h2>

<p>So docker does provide a solution for most people which is called boot2docker.  This solution
provides the native docker client for mac, virtualbox and a minimum linux os for virtualbox
that you can use as the docker daemon.</p>

<p>This is a great solution and fits the majority of requirements that people have.  For me, however,
I wanted to have a little more control over the virtual machine in use and so I have created a
script that I use to interact with docker while on my mac.  This script takes care of a number
of little issues for me, and while it is not perfect, it has been very helpful in making me forget
that there is a disconnect between mac and docker.</p>

<h2>Dependencies</h2>

<p>For the environment that I use there are a few things that first need to be installed on the system:</p>

<ol>
<li>docker native client</li>
<li>virtualbox (with extensions)</li>
<li><a href="http://vagrantup.com">vagrant</a></li>
</ol>


<p>That is all that is needed for this setup to work for you.</p>

<h2>The Script</h2>

<p>So the main part of this setup is the docker script (found below).  I basically hijack the docker
command and will instead have a fronted script whose purpose is to make sure that I am in a
good state before running the command.  It is broken down into a few sections.</p>

<h3>Vagrantfile</h3>

<p>Since I am running on a mac I have to use virtualization to work with docker, there is no getting
around that at the time this post was written.  To simplifying things, the script is in charge
of creating a home directory for the docker (by default ~/.docker) and laying down a Vagrantfile
that will be used to dynamically generate the virtual machine.</p>

<p>The box uses <code>ubuntu/trusty64</code> as the base image for the docker daemon.  It then sets up the
environment by adding the docker repo to the apt sources.  After that it updates apt and installs
a few packages, the most important of these being <code>lxc-docker</code>.  The vim and tmux packages are
there for when I need to work on that environment, and the openconnect package is there to
establish a vpn connection to my work (more on this later).</p>

<p>It then configures docker to enable remote connections over port 2375 to the docker daemon, and
finally allows an internal docker registry (using an non-global-cert) to still be accepted when
pulling images.</p>

<p>The last little bit of the file has to do with setting up a static local ip and port forwarding
for the docker container.  Now you may be wondering why it is that I need both a static ip and
the port forwarding to be setup.  This is actually because of an issue that is introduced when
I establish a vpn connection to my office using anyconnect. I believe that it is in the configuration
that is allowed by my organizations policies, but after the connection is opened direct access
to my local address block (192.168.53.X) is blocked.  I have read many different articles and seen
scripts that are supposed to fix this, but none of them were successful for me (I am sure I gave
up a little fast as well).</p>

<h3>Custom Commands</h3>

<p>The other thing that this script does for me is to extend the docker command with a few extra
commands that I use often.  Some of them are to interact with the underlying virtual machine,
while others are used to manage the daemon.  The best part is that any other commands are passed
forward to the actual docker client, so I am not losing any functionality.</p>

<ul>
<li>up</li>
<li>halt</li>
<li>destroy</li>
<li>clean</li>
<li>ssh</li>
<li>vpn</li>
<li>portf/noportf</li>
</ul>


<h4>up</h4>

<p>This command is simple, it will bring up the virtual machine if it is not running.  This command
is not necessary most of the time as the other docker commands (besides halt and destroy)
will check if there is a virtual machine running, and if not start it before executing the command.</p>

<h4>halt</h4>

<p>This command is used to stop the virtual machine.</p>

<h4>destroy</h4>

<p>This command is used to destroy the underlying virtual machine.  This is nice as it gives you an
easy way to upgrade the docker daemon, just destroy the current vm and rebuild.</p>

<h4>clean</h4>

<p>This command is the one that I find the most useful.  I am always having to clear out old running
containers and images that are no longer used.  This command will run two other bash functions.</p>

<p>One to clear the containers (and volumes):</p>

<pre><code>  $DOCKER_RUN ps -a | awk 'NR &lt;= 1 { next } NR &gt; 1 {print $1}' | xargs $DOCKER_RUN rm -v
</code></pre>

<p>And one to clear the extra images:</p>

<pre><code>  $DOCKER_RUN images | grep '&lt;none&gt;' -a | awk '{print $3}' | xargs $DOCKER_RUN rmi
</code></pre>

<h4>ssh</h4>

<p>Allows for ssh directly into the virtual machine.</p>

<h4>vpn</h4>

<p>Enables vpn on the virtual machine.  This lets me give access to internal repositories over vpn
without requiring my host to vpn.  This saves me from having to do port forwarding (which for some
reason with docker and virtualbox, it is incredible slow).</p>

<h4>portf/noportf</h4>

<p>This command is to enable or disable port forwarding use when connecting to the docker daemon.</p>

<h2>docker</h2>

<p><div><script src='https://gist.github.com/172093a8f0ab7542a568.js?file=docker'></script>
<noscript><pre><code>#!/bin/bash
# vi: set ft=bash :
DOCKER_RUN=/usr/local/bin/docker
DHOME=$HOME/.docker
RUN_FILE=/tmp/docker-vagrantup

if [ ! -d &quot;$DHOME&quot; ]; then
  if ! mkdir -p &quot;$DHOME&quot;; then
    echo &quot;Failed to create docker directory&quot;
    exit 1 
  else
    CAT &gt; &quot;$DHOME/Vagrantfile&quot; &lt;&lt;DOCKER_VAGRANTFILE
# -*- mode: ruby -*-
# vi: set ft=ruby :
# Vagrantfile API/syntax version. Don't touch unless you know what you're doing!
VAGRANTFILE_API_VERSION = &quot;2&quot;


\$script = &lt;&lt;PROVISION
sudo sh -c &quot;wget -qO- https://get.docker.io/gpg | apt-key add -&quot;
sudo sh -c &quot;echo deb http://get.docker.io/ubuntu docker main\ &gt; /etc/apt/sources.list.d/docker.list&quot;
sudo apt-get update
sudo apt-get install --assume-yes --force-yes lxc-docker vim tmux openconnect
sudo usermod -a -G docker vagrant
sudo echo &quot;DOCKER_OPTS='-H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock --insecure-registry docker-registry.vip.fsglobal.net'&quot; &gt;&gt; /etc/default/docker
sudo service docker restart
PROVISION

Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|
  # Note: If you would like to use a custom box you can grab them from https://www.vagrantbox.es, or https://vagrantcloud.com
  config.vm.box = &quot;ubuntu/trusty64&quot;
 
  config.vm.provision &quot;shell&quot;, inline: \$script
  config.vm.network :private_network, ip: &quot;192.168.53.100&quot;
  config.vm.network :forwarded_port, guest: 8080, host: 18080, protocol: 'tcp'
  config.vm.network :forwarded_port, guest: 3306, host: 13306, protocol: 'tcp'
  config.vm.network :forwarded_port, guest: 2375, host: 2375, protocol: 'tcp'
  config.vm.provider :virtualbox do |v|
    v.memory = 2048
    v.cpus = 4
  end
end
DOCKER_VAGRANTFILE
  fi
fi

function destroyDocker {
  local currentDirectory=$PWD
  cd $DHOME
  vagrant destroy
  if [[ $? -eq 0 ]]; then
    rm $RUN_FILE
    cd $currentDirectory
    rm -rf $DHOME
  else
    echo &quot;Failed to destroy&quot;
    cd $currentDirectory
  fi
}

function startDocker {
  local currentDirectory=$PWD
  cd $DHOME
  vagrant up
  touch $RUN_FILE
  cd $currentDirectory
}

function isRunning {
  local currentDirectory=$PWD
  cd $DHOME
  if [ ! -f $RUN_FILE ]; then
    startDocker  
  fi
  cd $currentDirectory
}

function stopDocker {
  local currentDirectory=$PWD
  cd $DHOME
  vagrant halt
  rm $RUN_FILE
  cd $currentDirectory
}

function vagrantSsh {
  local currentDirectory=$PWD
  cd $DHOME
  vagrant ssh
  cd $currentDirectory
}

function vagrantSSHVPN {
  local currentDirectory=$PWD
  cd $DHOME
  vagrant ssh -c &quot;sudo openconnect WORK_VPN_ENDPOINT&quot;
  cd $currentDirectory
}

function cleanupContainers {
  $DOCKER_RUN ps -a | awk 'NR &lt;= 1 { next } NR &gt; 1 {print $1}' | xargs $DOCKER_RUN rm -v
}

function cleanupImages {
  $DOCKER_RUN images | grep '&lt;none&gt;' -a | awk '{print $3}' | xargs $DOCKER_RUN rmi
}

function cleanup {
  cleanupContainers
  cleanupImages
}

if [ ! -f /tmp/docker-port-forward ]; then
  export DOCKER_HOST='tcp://192.168.53.100:2375'
else
  export DOCKER_HOST='tcp://127.0.0.1:2375'
fi

if [[ $1 = &quot;up&quot; ]]; then
  startDocker
elif [[ $1 = &quot;halt&quot; ]]; then
  stopDocker
elif [[ $1 = &quot;destroy&quot; ]]; then
  destroyDocker
elif [[ $1 = &quot;clean&quot; ]]; then
  isRunning
  cleanup
elif [[ $1 = &quot;ssh&quot; ]]; then
  isRunning
  vagrantSsh
elif [[ $1 = &quot;vpn&quot; ]]; then
  isRunning
  vagrantSSHVPN
elif [[ $1 = &quot;portf&quot; ]]; then
  touch /tmp/docker-port-forward
elif [[ $1 = &quot;noportf&quot; ]]; then
  rm -f /tmp/docker-port-forward
else
  isRunning
  $DOCKER_RUN &quot;$@&quot;
fi
</code></pre></noscript></div>
</p>
]]></content>
  </entry>
  
</feed>
