<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | My Fortress of Solitude]]></title>
  <link href="http://www.mikewright.me/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://www.mikewright.me/"/>
  <updated>2015-10-12T16:36:59-06:00</updated>
  <id>http://www.mikewright.me/</id>
  <author>
    <name><![CDATA[Michael Wright]]></name>
    <email><![CDATA[mkwright@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Let's do some Weld-ing]]></title>
    <link href="http://www.mikewright.me/blog/2015/10/12/lets-do-some-weld-ing/"/>
    <updated>2015-10-12T14:28:00-06:00</updated>
    <id>http://www.mikewright.me/blog/2015/10/12/lets-do-some-weld-ing</id>
    <content type="html"><![CDATA[<p>So I am no stranger to dependency injection (DI), having used it for many years (starting with
RhinoMocks on .net).  For my new company they are using a CDI implementation (Weld) which is one
framework that I have yet to use, so today I go over my experience with using this framework.</p>

<p>&lt;&mdash; more &mdash;></p>

<h2>Introduction</h2>

<p>So what is <a href="http://weld.cdi-spec.org/">weld</a> you might be asking.  Well Java in their &ldquo;infinite&rdquo;
wisdom, created a standard for the language to be set around dependency injection, or more
specifically around <a href="https://www.jcp.org/en/jsr/detail?id=299">&ldquo;Contexts and Dependency Injection for the Java EE Platform&rdquo;</a>.
This is known as JSR 299.</p>

<p>Since this standard was created (back in Dec. 2009) there are a few implementations of this
standard.  OpenWebBeans and CanDI are two of the other implementations, however for this article
I will specifically be covering the JBoss Weld implementation.</p>

<p>This specific implementation is for Java EE, however if you are using Java SE there is another
standard that was created as well <a href="https://jcp.org/en/jsr/detail?id=330">JSR 330 &ndash; &ldquo;Dependency Injection for Java&rdquo;</a>  <br/>
this is actually the standard that is implemented by Guice and Spring.  However Weld itself will
also work in a Java SE environment.</p>

<h2>CDI Standard</h2>

<p>One of the benefits of working with a standard when specifying DI mechanism, is that it can
abstract your implementation from the specific details that can a framework may have setup. This
in turn can allow you the option of swapping out implementations easily to determine which one
works best for your given scenario, or to easily replace a community technology that has lost
traction.</p>

<h2>Weld</h2>

<p>So how do we use weld?  Well the starting point is pretty simple, in the case of a wildfly
server, all that you would need to do is to create an application that wildfly can use and
add an associated pom to load the Weld libraries.</p>

<h3>Setup</h3>

<p>If you would like to follow along, these are the instructions that I used when testing out weld
with wildfly.  The tools I used are listed below (with their associated versions).</p>

<ol>
<li>Docker &ndash; 1.8.1</li>
<li>Maven &ndash; 3.3.3</li>
<li>Wildfly &ndash; 9.0.1 Final</li>
<li>Weld &ndash; 1.2</li>
</ol>


<p>Once these tools have all been installed the first thing you will need to do is to create
a maven project that works for this environment.  Luckily there is a usable archetype that we
can start the process from.  So run the below command (filling in your specific details).  For
this tutorial the project name that is created will be called &lsquo;weld-tutorial&rsquo;.</p>

<pre><code>mvn archetype:generate -Dfilter=org.wildfly.archetype:wildfly-javaee7-webapp-archetype    
</code></pre>

<p>Once the project has been created, enter the weld-tutorial directory and edit the pom.xml file. Add
the below block to the dependencies section.</p>

<pre><code>    &lt;dependency&gt;
      &lt;groupId&gt;javax.enterprise&lt;/groupId&gt;
      &lt;artifactId&gt;cdi-api&lt;/artifactId&gt;
      &lt;version&gt;1.2&lt;/version&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
</code></pre>

<p>At this point you should be able to build the maven project to created our deployable war.</p>

<pre><code>    mvn clean install
    ls target/*.war
</code></pre>

<p>Now we need to specify an application instance that this container can run in, so docker
to the rescue.  Below is the <code>Dockerfile</code> that I created to pull down the created wildfly image
and add our applications war file to the image.</p>

<pre><code>    FROM jboss/wildfly:9.0.1.Final
    ADD target/weld-tutorial.war /opt/jboss/wildfly/standalone/deployments/ROOT.war
</code></pre>

<p>Save this <code>Dockerfile</code> and run the below commands and we should have our application up
and running.</p>

<pre><code>    docker build -t weld-tutorial .
    docker run -it -p 8080:8080 weld-tutorial  
</code></pre>

<h3>Simple Details</h3>

<p>The core item that we need to discuss, is (of course) how to actually enable DI within this
framework.  Lucky for us, if you are starting from the archetype defined above a lot of the
plumbing has already been completed for you, leaving you to just add new functionality as
you see fit.</p>

<p>Lets start by creating a new &ldquo;Service&rdquo; that can be used to log the message &lsquo;Hello world&rsquo; when
the service <code>call</code> method is executed.  To do this, we first add a new class called
<code>HelloWorldService</code> inside the service package of the application.</p>

<p>For this class we actually have our first dependency, logging.  Now historically logging can
be created by just using a static lookup (such as getInstance).  With our implementation it is
already provided by the <code>Resources</code> class, so we just need to inject a copy into our class. This
is done simply using the <code>@Inject</code> attribute on the private member we need filled.</p>

<pre><code>    @Inject
    private Logger logger;
</code></pre>

<p>The one thing to note, is that since this is a property injection, we cannot use this object
within our constructor.  If we need to have it accessible inside the constructor, you can
instead inject the dependency in the constructor itself, and save it to a variable.</p>

<pre><code>    private Logger logger;

    @Inject
    public HelloWorldService(Logger logger) {
        this.logger = logger;
    }
</code></pre>

<p>Of course this style makes it easier to run your tests with the need to have a corresponding
framework, however this will run into problems later if you start requiring different scope
functionality.</p>

<p>Now that we have our dependency injected, lets see if we can get our service accessible from
the rest service.  To do this we have to register our service with the system, stating the
scope at which this service is usable.  The scope can be considered the life-cycle of the service
and there are a few different values (Although all based on @NormalScope).</p>

<ol>
<li>ApplicationScoped</li>
<li>RequestScoped</li>
<li>SessionScoped</li>
<li>ConversationScoped</li>
</ol>


<p>If you want the scope to be driven by the class that requires it, you can just use the
annotation <code>@Dependent</code> and it will have the same lifecycle as the class that requires it.</p>

<p>The one thing to note is that if a class is annotated with the <code>@ApplicationScoped</code> attribute
but has a dependency on a service that is annotated with <code>@RequestScoped</code> a proxy will be created
in place.  This proxy will be used to deliver the thread specific dependency, while deliverying
a single variable in the application scope class.  The one thing about this proxy, it has a
very strict requirement, in that the class that is having the proxy must have a no-arg ctor.</p>

<h2>Conclusion</h2>

<p>While there isn&rsquo;t a lot of details around weld or cdi in this article, now that it is one
that I will be using extensively in my current position, I hope to share more details about
how we use it, what pitfalls we encounter and where it has saved our bacon.</p>
]]></content>
  </entry>
  
</feed>
